## 얕은 복사와 깊은 복사

얕은 복사는 객체의 최상위 속성만 새로 복사하고, 내부에 있는 객체나 배열 같은 참조 타입은 원본과 주소를 공유합니다.
그래서 원시 타입은 독립적이지만, 중첩된 객체를 수정하면 원본도 함께 바뀌는 문제가 생깁니다.

반대로 깊은 복사는 중첩 객체까지 전부 새로운 메모리에 복사하기 때문에 원본과 완전히 독립됩니다.

예를 들어 React 상태 관리에서 얕은 복사를 쓰면 원본 상태가 의도치 않게 바뀔 수 있어 버그가 생길 수 있습니다. 이런 경우 JSON 직렬화 방식이나 structuredClone이나 lodash.cloneDeep 같은 깊은 복사 방식을 활용해 안전하게 상태를 관리를 할 수 있습니다.

+) JSON 직렬화는 객체를 문자열로 변환했다가 다시 파싱해서 복원하는 방식입니다. `JSON.stringify`와 `JSON.parse`를 이용하면 깊은 복사처럼 활용할 수 있습니다.
다만 함수나 undefined, Symbol은 직렬화되지 않고, Date 같은 객체는 문자열로 변환되는 한계가 있습니다. 그래서 간단한 데이터 구조에는 유용하지만, 복잡한 객체라면 structuredClone이나 라이브러리(lodash.cloneDeep 등)가 더 적합합니다.

---

💡 객체의 최상위 속성이란?

객체의 최상위 속성이란, 해당 객체 바로 아래 단계에 있는 프로퍼티를 말합니다.
즉, 중첩 객체의 “첫 번째 레벨 키(key)”들입니다.

```js
const user = {
  name: "Raina", // ✅ 최상위 속성 (원시 타입)
  age: 27, // ✅ 최상위 속성 (원시 타입)
  address: { city: "Seoul" }, // ✅ 최상위 속성 (참조 타입, 객체)
  skills: ["JS", "TS"], // ✅ 최상위 속성 (참조 타입, 배열)
};
```

• name, age, address, skills → user 객체의 최상위 속성
• address.city → 최상위 속성이 아니라, address 객체 안의 하위 속성
• skills[0] → 최상위가 아니라, 배열 skills 내부의 원소

얕은 복사에서 의미하는 것

```js
const copy = { ...user };
```

• name, age 같은 원시 타입 → 값 자체 복사
• address, skills 같은 참조 타입 → 객체/배열의 “주소”만 복사

즉, 최상위 레벨(address, skills)까지는 새로 만들어지지만, 그 안(city, 배열 원소)까지는 복사되지 않고 원본과 공유됨.
