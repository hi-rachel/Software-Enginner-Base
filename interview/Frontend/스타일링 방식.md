## 스타일링 방식

전통 CSS와 Sass는 정적 스타일링에 강점이 있고 런타임 오버헤드가 없지만, 코드 중복이나 전역 스코프 충돌 문제가 발생할 수 있습니다. 반면 CSS-in-JS는 컴포넌트 단위 캡슐화와 props 기반 동적 스타일링에 강력하지만, 빌드 타임이나 런타임에서 CSS를 생성하기 때문에 런타임 오버헤드가 발생할 수 있어 성능 측면에서는 불리할 수 있습니다. Tailwind는 이러한 성능 문제가 없고, 재사용성과 디자인 일관성을 확보하는 데 유리합니다. 다만 학습 곡선이 있고 HTML에 클래스가 과도하게 나열되면 가독성이 떨어질 수 있다는 단점이 있습니다.

따라서 스타일링 방식을 선택할 때는 프로젝트 규모, 협업 방식, 동적 스타일 필요 여부, 성능 요구, 디자인 시스템 적용 여부 등을 종합적으로 고려해 적절한 접근 방식을 선택해야 합니다.

| 구분        | **Sass (SCSS)**                        | **Styled-Components**                                     | **Tailwind CSS**                                 |
| ----------- | -------------------------------------- | --------------------------------------------------------- | ------------------------------------------------ |
| 패러다임    | **CSS 전처리기**                       | **CSS-in-JS** (Runtime/Build)                             | **유틸리티-퍼스트** 프레임워크                   |
| 작성 방식   | SCSS 파일로 변수·믹스인·중첩           | JS/TS 파일 안에서 컴포넌트 단위 스타일                    | 클래스 유틸리티 조합으로 마크업에 직접 스타일    |
| 스코프      | 전역(모듈화 필요: CSS Modules 등)      | **컴포넌트 단위 캡슐화(자동 고유화)**                     | 전역 유틸리티, 충돌 거의 없음                    |
| 동적 스타일 | 제한적(클래스 토글)                    | **props/상태로 즉시 반응**                                | 조건부 클래스로 토글(`clsx`)                     |
| 테마        | 변수/믹스인으로 구현                   | **ThemeProvider**로 다크/브랜드 테마 용이                 | `tailwind.config.js`의 design tokens             |
| 성능 비용   | 빌드 타임만 관여, 런타임 오버헤드 없음 | **런타임 오버헤드**(babel 매크로/빌드 최적화로 완화 가능) | **정적 클래스**+Purge/Content 스캔으로 소형 번들 |
| 학습/생산성 | CSS 친숙, 대규모 아키텍처는 규칙 필요  | React 친화/재사용성↑, 빌드세팅·디버깅 학습 필요           | 생산성↑, **HTML이 장황**해질 수 있음             |
| 재사용성    | 믹스인/플레이스홀더                    | 스타일 컴포넌트 재사용                                    | 유틸리티/컴포넌트 프리셋(예: shadcn/ui)          |
| SSR/CSR     | 무관                                   | SSR 시 스타일 주입 순서 관리 필요                         | 무관                                             |
| 사용 적합도 | **디자이너-친화**, 전통 CSS 워크플로우 | **컴포넌트 설계 중심 프로젝트**                           | **속도·일관성·디자인 시스템** 강조               |

## SASS란

- 정의: **CSS 전처리기(Preprocessor)**, .scss 문법으로 작성 후 CSS로 컴파일

- 주요 기능: 변수($primary-color), 중첩, 믹스인, 상속(@extend) 등

- 장점: 전통 CSS보다 생산성 높음, 디자이너-퍼블리셔에게 친숙, 런타임 오버헤드 없음 (빌드 시점에 CSS로 변환되어 브라우저 동작과 동일)

- 단점: 전역 스코프 충돌, 코드 중복, 큰 프로젝트에서 관리 어려울 수 있음, 동적 스타일링은 JS 연동 필요

## CSS-in-JS란

- 특징: 스타일을 JS/TS 파일 안에서 정의 (styled-components, emotion 등), **런타임 또는 빌드 타임에 CSS 생성**

- 장점: 컴포넌트 단위 캡슐화(스코프 자동 관리), props/state 기반 동적 스타일링 가능, ThemeProvider로 테마 관리 용이

- 단점: **런타임 오버헤드 발생**, 빌드/디버깅 복잡, 번들 크기 증가 가능

---

### SASS 용어

💡 변수 (Variables)

정의: 반복적으로 쓰이는 값을 저장해두고 재사용 가능.

장점: 색상, 폰트 크기, spacing 단위 등을 변수화해 디자인 시스템 유지 용이.

예시:

```css
$primary-color: #3490dc;
$spacing-unit: 16px;

.button {
  background: $primary-color;
  padding: $spacing-unit;
}
```

색상을 바꾸고 싶을 때 변수만 수정하면 전체 반영.

💡 믹스인 (Mixins)

정의: 재사용 가능한 스타일 블록을 정의하고, 필요할 때 @include로 불러와 적용.

장점: 반복되는 스타일(벤더 프리픽스, 미디어 쿼리)을 간단하게 재사용 가능.

예시:

```css
@mixin flex-center {
  display: flex;
  justify-content: center;
  align-items: center;
}

.card {
  @include flex-center;
}
```

중복 제거 + 유지보수성 향상.

💡 중첩 (Nesting)

정의: CSS 셀렉터를 계층 구조로 중첩해 작성 가능.

장점: 코드 가독성 향상, HTML 구조와 스타일 구조를 직관적으로 매칭.

예시:

```css
.nav {
  ul {
    list-style: none;
  }
  li {
    display: inline-block;
  }
  a {
    text-decoration: none;
  }
}
```

최종 출력:

```css
.nav ul {
  list-style: none;
}
.nav li {
  display: inline-block;
}
.nav a {
  text-decoration: none;
}
```

---

### Tailwind CSS 용어

💡 유틸리티-퍼스트(Utility-First)란?

- 정의: 미리 정의된 원자적 클래스(utility class)를 조합해서 UI를 만드는 스타일링 접근 방식.

> Utility Class란?
>
> - 정의: 하나의 작은 스타일 속성만 담당하는 단일 목적 클래스.
>
> - 예를 들어 text-center, p-4, bg-blue-500 같은 클래스는 각각 “텍스트 중앙 정렬”, “padding 1rem”, “배경 파란색”만 지정.
>
> - 즉, 재사용 가능한 CSS 속성 단위 블록이라고 볼 수 있음.

- 예시: p-4, text-center, bg-blue-500 처럼 의미 단위가 아닌 속성 단위 클래스를 제공.

- 장점

  - 재사용성과 일관성 확보 (디자인 토큰 강제)

    - Tailwind 같은 프레임워크는 spacing, color, typography 등을 토큰화해 제공.

    - 팀원 모두 같은 단위를 사용하므로 디자인 시스템이 자연스럽게 유지됨.

  - 빠른 개발 속도 (HTML 내에서 바로 스타일 적용)

  - 불필요한 CSS 작성 최소화

    - 새로운 컴포넌트마다 별도 CSS 파일 정의 필요 없음.
    - 중복된 스타일 규칙 줄어듦.

  - 충돌 방지
    - 클래스가 속성 단위로 분리돼 있어 네이밍 충돌 문제 거의 없음.

- 단점

  - 가독성 저하
    - HTML 태그에 수많은 클래스가 나열되면 한눈에 파악하기 어려움.
  - 추상화 부족
    - 의미 있는 이름(.button-primary) 대신 속성 나열만 있어 의미 전달력이 떨어짐.
    - 디자인 패턴 재사용시에는 컴포넌트 추출 필요.
  - 학습 곡선
    - 유틸리티 네이밍을 외워야 함, CSS 기본 지식과 별개로 추가 학습 필요.
  - 커스터마이징 한계
    - 제공되지 않는 특수한 스타일은 여전히 custom CSS 필요 (복잡한 @keyframes 기반 애니메이션, @layer utilities).

- 전통 CSS 클래스와의 차이

  - 전통 CSS: 보통 하나의 클래스에 여러 속성이 들어감 → 컴포넌트별 스타일 정의 (.button { ... }).
  - Utility class: 속성을 세분화해서 HTML에 바로 클래스 조합으로 스타일 적용 가능.

💡 Purge 과정이란?

- 정의: TailwindCSS가 빌드 시 실제로 HTML/JSX/TSX 코드에서 **사용된 클래스만 추출해 최종 CSS에 포함시키는 과정**.

- 목적: 기본 Tailwind는 수천 개의 유틸리티 클래스를 제공하기 때문에, 그대로 번들링하면 CSS 파일 크기가 매우 커짐.

- 작동 방식:

  - 소스 코드(.html, .tsx, .vue 등)를 스캔 → 사용된 클래스만 식별.
  - 나머지 사용되지 않는 클래스는 CSS 빌드 결과에서 제거.
  - 효과: 최종 CSS 용량이 수십 MB에서 수십 KB 수준으로 줄어듦.

요약: **Purge는 사용하지 않는 CSS를 제거해 최적화하는 빌드 단계**.

💡 @layer란?

TailwindCSS는 스타일을 세 가지 계층(layer) 으로 나눔:

- base: 브라우저 기본 스타일 초기화나 HTML 태그 단위 스타일 (예: h1 { ... })

- components: 버튼, 카드 같은 컴포넌트 수준 스타일

- utilities: p-4, bg-blue-500 같은 원자적 유틸리티 클래스

**@layer**는 이 계층에 사용자 정의 스타일을 안전하게 추가하기 위한 Tailwind의 디렉티브.

예시:

```css
@layer utilities {
    .scrollbar-hide {
        -ms-overflow-style: none; /_ IE and Edge _/
        scrollbar-width: none; /_ Firefox _/
    }
    .scrollbar-hide::-webkit-scrollbar {
        display: none; /_ Chrome, Safari _/
    }
}
```

이렇게 하면 scrollbar-hide라는 새로운 유틸리티 클래스를 Tailwind 생태계에 추가 가능.

Purge 과정에서도 제거되지 않고 안전하게 포함됨.

💡 @keyframes란?

CSS 애니메이션의 핵심 규칙.

**애니메이션의 중간 단계(프레임)를 정의해 특정 속성이 시간에 따라 어떻게 변화할지를 지정**.

예시:

```css
@keyframes wiggle {
  0%,
  100% {
    transform: rotate(-3deg);
  }
  50% {
    transform: rotate(3deg);
  }
}

@layer utilities {
  .animate-wiggle {
    animation: wiggle 1s ease-in-out infinite;
  }
}
```

@keyframes wiggle → 애니메이션 정의

@layer utilities 안에서 .animate-wiggle 클래스 생성 → HTML에서 바로 사용 가능

```html
<button class="animate-wiggle">흔들려요</button>
```
