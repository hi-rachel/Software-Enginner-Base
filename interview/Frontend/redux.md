# Redux

### Redux의 핵심 원칙(3대 원칙)

1. 단일 스토어(Single source of truth) — 앱 전체 상태는 하나의 스토어에서 관리합니다.
2. 읽기 전용 상태(State is read-only) — 직접 수정하지 않고 오직 액션을 통해서만 변경됩니다.
3. 순수 함수로 변경(Pure functions) — 상태 변경은 순수 함수인 리듀서로만 수행되어 예측 가능합니다.

“Redux는 상태를 한 곳에서 관리하고, 오직 액션과 순수 리듀서를 통해 변경되기 때문에 디버깅이 쉽고 예측 가능한 구조를 유지할 수 있습니다.”

⸻

### Redux의 동작 흐름

1. 사용자가 어떤 이벤트를 발생시키면
2. 액션 객체(Action) 가 dispatch 되고,
3. 리듀서(Reducer) 가 이전 상태와 액션을 받아 새로운 상태를 반환하고,
4. 스토어(Store) 가 이 새로운 상태를 모든 구독 컴포넌트에 전달합니다.

“Dispatch → Reducer → Store → UI 반영”
이렇게 단방향 데이터 흐름을 유지합니다.

⸻

### Redux에서 비동기 처리

- Redux Thunk: 액션 대신 함수를 dispatch할 수 있게 해주는 미들웨어로, 간단한 API 호출에 적합.
- Redux Saga: Generator를 이용한 비동기 흐름 제어로, 복잡한 사이드 이펙트 처리에 강함.
- RTK Query: Redux Toolkit 내장 데이터 패칭 솔루션으로, 서버 상태 관리까지 통합 가능.

“단순한 비동기 로직엔 Thunk, 복잡한 흐름 제어나 트랜잭션엔 Saga, 서버 데이터 캐싱엔 RTK Query를 씁니다.”

⸻

### Redux의 단점

- 설정이 복잡하고, 코드가 장황한 보일러플레이트가 많습니다.
- Redux Toolkit(RTK) 등장 이후 createSlice, createAsyncThunk 등을 통해 코드가 보다 간결해졌습니다.

⸻

### Redux는 왜 불변성을 유지해야 하나요?

Redux는 이전 상태와 새 상태를 비교해서 변경 여부를 감지하는데,

불변성을 지켜야 === 비교로 리렌더링 여부를 정확히 판단할 수 있습니다.

불변성이 깨지면 UI가 갱신되지 않거나, 예측 불가능한 버그가 발생할 수 있습니다.

✨ 짧게 말하자면:
“불변성을 유지해야 React가 효율적으로 변경을 감지할 수 있고, 예측 가능한 상태 관리가 가능합니다.”

⸻

### “Redux와 React Query(또는 SWR) 같이 써야 하나요?”

- Redux는 클라이언트 상태(앱 내부 UI 상태) 관리용,
- React Query는 서버 상태(백엔드 데이터) 캐싱 및 동기화용.
