## 상태 관리

## 라이브러리

### Redux

“Redux는 전역 상태를 한 곳에서 관리하고, 상태 변경을 액션과 리듀서로 명확하게 정의하는 라이브러리입니다.
모든 상태 변화가 예측 가능하고 추적 가능하기 때문에, 대규모 프로젝트나 여러 명이 함께 개발하는 환경에서 안정성이 높습니다.”

• 장점: 상태 흐름이 명확해서 디버깅이 쉽고, Redux DevTools로 타임트래블 디버깅이 가능합니다. 또 Redux Toolkit을 쓰면 보일러플레이트 코드가 많이 줄어들고 타입스크립트 호환도 좋아요.

• 단점: 구조가 엄격하고 초기 설정이 다소 복잡해서, 간단한 프로젝트에는 오히려 과한 경우가 있습니다.

포인트: “Redux는 상태 변경을 예측 가능하게 만들고, 대규모 협업에 적합합니다.”

⸻

### Zustand

“Zustand는 훨씬 가볍고 직관적인 전역 상태 관리 라이브러리예요.
useStore 훅 하나로 상태를 가져오고 변경할 수 있고, selector를 이용해 필요한 부분만 구독해서 성능도 좋아요.”

• 장점: 코드가 단순하고 러닝 커브가 낮습니다. 불필요한 리렌더링이 거의 없고, persist나 immer 같은 미들웨어를 쉽게 붙일 수 있습니다.

• 단점: 구조가 자유로운 만큼 팀마다 코드 스타일이 달라질 수 있고, Redux처럼 액션 로그나 미들웨어 중심의 패턴이 없습니다.

포인트: “Zustand는 간결함과 성능이 장점이에요. 복잡한 구조보다 빠른 개발이 필요할 때 유용합니다.”

⸻

### Jotai

“Jotai는 ‘atom’ 단위로 상태를 관리하는 방식이에요.
각 atom이 독립적인 상태를 갖고, 필요할 때 파생 상태를 selector처럼 만들어서 조합할 수 있습니다.”

• 장점: 상태를 세분화해서 필요한 컴포넌트만 리렌더링되므로 효율적이고, 비동기 상태나 파생 상태를 관리하기 쉽습니다.

• 단점: atom이 많아질수록 관리가 복잡해질 수 있고, 디버깅 도구나 생태계는 Redux만큼 강력하진 않습니다.

포인트: “Jotai는 작은 단위의 상태를 조립해서 쓰기 때문에, 파생 상태나 독립적인 컴포넌트가 많은 구조에 적합합니다.”

⸻

### Recoil

“Recoil은 Facebook에서 만든 상태관리 라이브러리로, React의 철학과 잘 맞는 ‘atom’과 ‘selector’ 개념을 제공합니다.
selector를 통해 상태 간의 의존성을 자연스럽게 표현할 수 있어요.”

• 장점: atom 간의 의존관계를 자동으로 추적하고, selector로 파생 상태나 비동기 데이터를 쉽게 처리할 수 있습니다.

• 단점: 생태계가 Redux만큼 크지 않고, 서버 컴포넌트나 SSR 환경에선 추가 설정이 필요할 수 있습니다.

포인트: “Recoil은 의존성 그래프 기반이라 파생 상태가 많은 프로젝트에서 유용합니다.”

⸻

### MobX

“MobX는 관찰자 패턴을 기반으로 한 반응형 상태관리 라이브러리예요.
상태를 observable로 만들고, 컴포넌트가 이를 자동으로 감지해서 리렌더링됩니다.”

• 장점: 매우 선언적이고 직관적이에요. 상태와 파생 상태를 자동으로 추적해서 코드가 간결해지고, 불변성을 직접 관리하지 않아도 됩니다.

• 단점: 내부 동작이 마법처럼 느껴질 만큼 자동화되어 있어서, 디버깅이나 상태 흐름 추적이 어려울 수 있습니다.

포인트: “MobX는 반응형 패러다임이라 코드량은 적지만, 명시적인 제어가 필요한 팀에선 선호도가 낮습니다.”

⸻

### xState

“xState는 상태머신(state machine) 기반의 상태관리 라이브러리로,
앱의 상태를 ‘현재 상태와 그 상태에서 가능한 전이(transition)’로 명확하게 정의합니다.
즉, 단순히 상태값을 저장하는 게 아니라 상태 간의 이동 규칙 자체를 설계하는 방식이에요.
이 접근 방식 덕분에 로딩, 성공, 실패처럼 상태 전환이 명확한 UI 흐름을 예측 가능하고 안정적으로 관리할 수 있습니다.”

• 장점:

• 상태 전이가 모두 명시되어 있어서 예측 가능성이 높고, 의도치 않은 상태 전환이 발생하지 않습니다.

• 시각화 도구(stately.ai)를 통해 상태 흐름을 시각적으로 표현할 수 있어, 디자이너·기획자와 협업이 쉽습니다.

• 복잡한 단계 기반 UI(폼, 결제, 인증 절차 등)나 비동기 로직이 여러 단계로 나뉘는 흐름을 명확하게 표현하기 좋습니다.

• 단점:

• 비교적 학습 곡선이 높고, 처음엔 상태머신 개념(이벤트, 전이, 가드 등)이 낯설 수 있습니다.

• 단순한 상태에는 오히려 코드가 복잡해지고 보일러플레이트가 많아집니다.

포인트:
“xState는 상태를 ‘값’이 아니라 ‘행동(전이)’ 중심으로 관리하는 라이브러리입니다.
상태 전이가 명시적이라 버그를 줄이고, 복잡한 UI 플로우를 예측 가능하게 만드는 데 강점이 있습니다.”

⸻

### MobX

“MobX는 관찰자 패턴을 기반으로 한 반응형 상태관리 라이브러리예요.
상태를 observable로 만들고, 컴포넌트가 이를 자동으로 감지해서 리렌더링됩니다.”

• 장점: 매우 선언적이고 직관적이에요. 상태와 파생 상태를 자동으로 추적해서 코드가 간결해지고, 불변성을 직접 관리하지 않아도 됩니다.

• 단점: 내부 동작이 마법처럼 느껴질 만큼 자동화되어 있어서, 디버깅이나 상태 흐름 추적이 어려울 수 있습니다.

포인트: “MobX는 반응형 패러다임이라 코드량은 적지만, 명시적인 제어가 필요한 팀에선 선호도가 낮습니다.”

⸻

### Context API

“Context API는 React가 기본적으로 제공하는 전역 상태 주입 기능이에요.
보통 테마나 언어 설정, 로그인 정보처럼 변경이 자주 일어나지 않는 전역 데이터를 공유할 때 사용합니다.”

• 장점: 별도 라이브러리 없이 쓸 수 있고, Provider/Consumer 패턴으로 단순합니다.

• 단점: 값이 바뀔 때 Provider 하위 모든 컴포넌트가 리렌더링되기 때문에, 자주 변하는 상태엔 성능 이슈가 있습니다.

포인트: “Context는 전역 상태보단 전역 ‘값 주입’에 적합하고, 자주 바뀌는 데이터엔 부적합합니다.”

--

## Hooks

### useReducer

“useReducer는 컴포넌트 내부에서 리듀서 패턴을 구현할 수 있는 훅이에요.
상태 전이 로직을 한 곳에서 관리할 수 있어서, 복잡한 폼이나 여러 단계의 상태 변화를 다루기 좋습니다.”

• 장점: 액션 기반 상태 전이가 명확하고, 테스트나 유지보수에 용이합니다.

• 단점: 단순한 상태엔 오히려 코드가 길어지고, 비동기 로직은 직접 관리해야 합니다.

포인트: “useReducer는 컴포넌트 단위의 작은 Redux 같은 개념입니다.”

⸻

### useSyncExternalStore

“useSyncExternalStore는 React 18에서 도입된 훅으로, React 외부에 있는 스토어를 React와 동기화할 때 사용합니다.
Zustand 같은 라이브러리 내부에서도 이 훅을 활용해서 상태를 일관되게 유지합니다.”

• 장점: 외부 상태 변화가 React 렌더링과 정확히 동기화되어, concurrency나 strict mode에서도 안정적으로 작동합니다.

• 단점: 직접 쓰기보다는 라이브러리 내부에서 사용되는 경우가 많고, 구현 시 subscribe/getSnapshot을 정확히 정의해야 합니다.

포인트: “React가 외부 스토어와 안전하게 동기화되도록 보장하는 훅입니다. 대부분의 상태관리 라이브러리들이 내부적으로 이걸 이용합니다.”

---

[참고]

https://github.com/toss/frontend-fundamentals/discussions/5
