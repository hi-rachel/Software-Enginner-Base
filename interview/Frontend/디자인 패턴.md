## 디자인 패턴

### MVC

- 모델: 데이터와 비즈니스 로직을 관리합니다.
- 뷰: UI 렌더링합니다.
- 컨트롤러: 유저 인터랙션을 처리하고 모델과 뷰를 업데이트합니다.

> 컨트롤러가 입력을 받고, 모델에서 데이터를 조회해서 받은 다음에 응답 View 생성.

### MVVM

- 모델: API를 호출해 데이터를 불러오는 등 도메인 사용에 필요한 데이터를 관리하고, 주요 비즈니스 로직을 관리합니다.
- 뷰: UI를 렌더링합니다. HTML, EJS, 핸들바JS와 같은 템플릿 언어 혹은 마크업으로 이루어져 있습니다.
- 뷰모델: **구독할 수 있는 상태를 외부로 노출하며 상탯값을 변경할 수 있는 로직을 작성하고 뷰에서 사용할 수 있는 메서드만 외부로 노출**합니다. 애플리케이션 규모에 따라 모델의 역할을 뷰모델에서 대체할 수 있습니다.

> View 또는 ViewModel에 변경사항이 일어나면 서로 업데이트.
> 양방향 데이터 바인딩으로 자동 UI 업데이트.

예시:

- Vue
- Angular

### MVP

- 모델: 데이터와 비즈니스 로직을 관리합니다.
- 뷰: UI를 렌더링합니다. 가능한 한 수동적(Passive View)이며 프레젠터가 넘겨준 데이터만 표시합니다.
- 프레젠터: 유저 인터랙션을 처리하고 모델을 갱신한 뒤, 갱신 결과를 뷰에 반영합니다.

> 뷰가 이벤트를 프레젠터에 전달하고, 프레젠터가 모델을 업데이트한 다음 표시용 데이터로 가공해 뷰에 전달.
> 테스트 용이성이 높고, 복잡한 프레젠테이션 로직을 프레젠터에 집중시킬 수 있습니다.

예시:

- Web: Passive View + Presenter 구성 (프레젠터가 DOM 업데이트 제어)

### FLUX

- 액션: 무엇이 발생했는지를 서술하는 객체입니다.
- 디스패처: 중앙 허브로, 액션을 모든 스토어에 전파(broadcast)합니다.
  > 모든 Store가 Dispatcher에 등록(register) 되어 있고, Dispatcher는 Action이 발생하면 이를 등록된 모든 Store에 전달(dispatch) 합니다. 다만 실제 로직 처리 여부는 각 Store가 스스로 판단합니다.
- 스토어: 상태와 도메인 로직을 보유하고 액션을 처리합니다. 변경 시 뷰에 변경을 통지합니다.
- 뷰: (예: 리액트 컴포넌트) 스토어를 구독해 렌더링하고, 유저 입력 시 액션을 발생시킵니다.

> 단방향 데이터 흐름: **View → Action → Dispatcher → Store → View**.
>
> 상태 변경이 한 방향으로만 흐르므로 추론 가능성과 예측 가능성이 높습니다.

예시:

- Redux
  > Redux는 Flux 아이디어를 단순화한 구현.
  >
  > Redux는 Flux에서 Dispatcher를 제거하고 하나의 중앙 Store를 두는 구조.
  >
  > 그래서 Redux에서는 액션이 “모든 스토어”로 퍼질 필요 없이 하나의 리듀서 트리에서 처리됨.
- Recoil, Zustand (리액트 생태계의 단방향 상태 관리)

---

💡 양방향 바인딩

**UI의 변경이 즉시 상태를 업데이트하고 상태의 변경이 추가 보일러플레이트 코드 작성 필요 없이 UI에 자동으로 반영되는 패턴**입니다.

예시: Svelte, Vue, Angular 등

💡 단방향 바인딩

UI는 상태 기반으로 렌더링되지만 유저 입력이 자동으로 데이터의 변경을 발생시키지는 않습니다.
일반적으로 상태 업데이트를 처리하기 위해 별도의 이벤트 핸들러를 작성해야 합니다.

💡 데이터 바인딩

**텍스트 입력과 같은 UI 엘리먼트의 동작을 상태에 연결하여 동기화를 유지하는 프로세스**를 말합니다.
MVVM 프레임워크에서는 앵귤러의 ngModel, Vue.js의 v-model이 있습니다.

---

[참고]

https://bitbetter.vercel.app/blog/frontend/mvc-mvvm-mvp-flux

단테, 『다시 깊게 익히는 인사이드 리액트』, 골든래빗(2025), p.107

https://www.youtube.com/watch?v=Y5vOfv67h8A
