## 렌더링 방식

### CSR

**클라이언트 사이드 렌더링은 브라우저가 최소한의 HTML과 자바스크립트를 받아와 동적으로 페이지를 렌더링하는 방식**입니다. 풍부한 상호작용과 네이티브 앱과 같은 유저 경험을 제공할 수 있지만, **페이지 초기 로딩이 느릴 수 있고 검색 엔진 최적화에 불리**할 수 있습니다.

> 컴포넌트 상단 'use client' 선언시 CSR로 동작

### SSR

**서버 사이드 렌더링은 서버에서 유저의 각 요청마다 렌더링할 준비가 된 HTML을 생성하여 응답하는 방식**입니다. **빠른 초기 로딩 및 풍부한 SEO를 전달**할 수 있습니다.

> App Router에서는 fetch에 { cache: 'no-store' } 옵션시 SSR 동작 (ver.15 기본값)

### SSG

**정적 사이트 생성은 빌드 시점에 모든 페이지를 미리 HTML 파일로 생성해두고 요청 즉시 제공하는 방식으로 서버 부하 없이 안정적이고 빠른 속도로 콘텐츠를 제공할 수 있으나 데이터 변경 시 전체 사이트를 다시 빌드**해야 합니다.

> App Router에서는 fetch에 cache: 'force-cache'를 사용하면 SSG로 동작합니다. (ver.14 기본값)

### ISR

**증분 정적 재성성은 정적 사이트 생성을 기반으로 정해진 주기마다 정적 페이지를 점진적으로 다시 생성하여 업데이트하는 방식**으로 **정적 사이트 생성의 속도와 서버 사이드 렌더링의 최신 데이터 사용 능력을 절충**하는 방식을 채택합니다.

> App Router에서는 fetch에 next: { revalidate: N } 옵션을 주면 ISR이 적용됩니다.

### Next.js 15

- Next.js 14 이하: fetch의 기본 옵션은 `cache: 'force-cache'` (SSG, 정적 캐싱)
- Next.js 15 이상: fetch의 기본 옵션이 `no-store` (SSR, 매 요청마다 서버 패칭)로 변경됨

  즉, Next.js 15 이상에서는 별도 옵션 없이 fetch를 사용하면 SSR(서버사이드 렌더링)이 기본 동작입니다.

---

### 서버 컴포넌트

JS 번들에 포함되지 않는 컴포넌트로 데이터 호출을 컴포넌트 내부에서 직접 수행할 수 있으며 자바스크립트 번들 크기를 최소화하고 백엔드 리소스에 직접 접근할 수 있습니다. useState(), useEffect() 등 리액트 훅 및 이벤트 핸들러 부착 등 상호작용을 위한 로직을 작성할 수 없습니다.

### 클라이언트 컴포넌트

기존의 리액트 컴포넌트와 동일하며 브라우저에서 실행되고 유저와의 인터랙션과 상태 관리를 담당합니다. useState() 등 리액트 훅 사용이 가능하며 수화 과정이 필요해 추가적인 자바스크립트 번들 파일을 다운받아야 합니다.

### 하이드레이션(Hydration)

**서버에서 렌더링된 HTML을 클라이언트로 전달하고, 클라이언트에서 JS가 실행되면서 초기 상태를 클라이언트와 동기화하는 과정**을 말합니다.

---

### SPA

싱글 페이지 애플리케이션은 단일 HTML 페이지에서 내려받는 자바스크립트를 사용하여 페이지 전환시 전체 페이지를 리프레시 하지 않아도 되는 애플리케이션을 의미하며, 리액트, 뷰, 앵귤러, 스벨트 등이 있습니다.

> CSR: 초기 로딩 시 브라우저가 JS 번들을 받아 → 빈 HTML에 React가 런타임에서 DOM을 채움.
>
> SSR: 브라우저는 초기에 완성된 HTML을 받아 바로 보여주고, 이후 React가 하이드레이션(hydration)으로 SPA처럼 동작.

---

[참고]

https://bitbetter.vercel.app/blog/frontend/nextjs/ssr-ssg-csr-isr

https://velog.io/@leejpsd/pt

단테, 『다시 깊게 익히는 인사이드 리액트』, 골든래빗(2025), p.636
