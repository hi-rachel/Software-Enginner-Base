## 클로저

**클로저는 자신이 속한 렉시컬 스코프를 기억하여 함수가 렉시컬 스코프 밖에서도 실행될 때 그 스코프에 접근할 수 있게 하는 기능**을 말합니다.

**즉, 외부와 내부 함수가 있을때, 외부함수 실행이 끝나더라도 내부함수는 외부함수의 변수를 참조할 수 있습니다.**

```js
function outer() {
  var a = 2;
  function inner() {
    console.log(a);
  }
  return inner;
}
var func = outer();
func(); // 2
```

여기서 GC([GarbageCollector](https://github.com/Esoolgnah/Frontend-Interview-Questions/blob/main/Notes/important-5/closure.md#gear-garbagecollector))가 outer() 의 참조를 없앨 것 같지만 **내부함수인 inner() 가 해당 스코프의 변수인 a를 참조하고 있기 때문에 없애지 않습니다**. 따라서 스코프 외부에서 inner() 가 실행되도 해당 스코프를 기억하기 때문에 2를 출력하게 됩니다. 즉, **여기서 클로저는 inner()** 가 되며 **func에 담겨 밖에서도 실행되고 렉시컬 스코프를 기억합니다.**

위와 같은 방식으로 JS에는 없는 캡슐화라는 개념을 구현할 수 있고 정보 은닉과 캡슐화가 가져다주는 이점들을 얻을 수 있습니다.

### 클로저(Closure)를 사용하는 이유

클로저를 사용하는 이유는 크게 두 가지로 정리할 수 있습니다.

첫째, **함수가 선언될 당시의 환경을 기억해서 실행이 끝나도 상태를 유지**할 수 있고,

둘째, **특정 변수를 외부에서 직접 접근하지 못하게 하여 데이터 은닉이 가능**하다는 점입니다.

그래서 카운터, 모듈 패턴, 이벤트 핸들러 같은 상황에서 클로저가 자주 사용됩니다.

1. 데이터 은닉 및 캡슐화

   - 함수 내부 변수는 외부에서 직접 접근할 수 없지만, 클로저를 이용하면 선택적으로 접근 권한을 열어줄 수 있습니다.

   - → private 변수처럼 동작해 정보 은닉이 가능합니다.

2. 상태 유지

   - 일반 함수는 실행이 끝나면 지역 변수가 사라지지만, 클로저는 함수가 선언될 당시의 환경을 기억합니다.

   - → 여러 번 호출할 때도 이전 상태를 유지할 수 있습니다. (ex. 카운터)

3. 콜백/비동기 로직에서 유용

   - setTimeout, 이벤트 핸들러, Promise 체인 등에서 바깥 스코프 변수를 안전하게 참조할 수 있습니다.

   - → JS의 비동기 처리와 잘 맞습니다.

4. 함수형 프로그래밍 활용

   - 고차 함수에서 특정 값이나 환경을 묶어서 전달하는 방식으로 재사용성과 가독성을 높입니다.

   - → 커링(Currying), 부분 적용 함수 등 패턴 구현에 활용됩니다.

---

### ⚛️ useState와 클로저

**useState가 반환하는 setter 함수는 상태 변경을 예약하는 클로저**입니다.

**이 setter는 선언 시점의 컴포넌트 스코프를 기억하고 있어, 컴포넌트가 리렌더링 되어도 올바른 state 스코프를 참조**합니다.

예시:

```js
const [count, setCount] = useState(0);

function handleClick() {
  setCount((prev) => prev + 1); // prev는 클로저로 기억된 이전 상태
}
```

여기서 prev는 클로저 덕분에 항상 최신 상태 값을 안전하게 참조할 수 있습니다.

#### 렌더링과 클로저 함정

컴포넌트 함수가 다시 실행될 때마다 새로운 스코프가 생기므로, 잘못된 클로저 사용은 stale state 문제(오래된 값 참조)를 일으킬 수 있습니다.

→ 그래서 useEffect의 deps 배열 관리나, useCallback, useMemo 같은 훅이 함께 쓰입니다.

---

💡 렉시컬 스코프란?

**렉시컬 스코프**란 **함수를 선언한 시점에 상위 스코프가 결정되는 것**을 말합니다.

💡 GC(GarbageCollector)란?

**메모리에 할당된 값이 더는 필요하지 않다고 판단될때 메모리를 해제시키는 과정**을 가비지 컬렉션이라고 부르며 이 역할을 가비지 컬렉터가 맡고 있습니다. 가비지 컬렉터가 ‘필요없다’라고 판단하는 기준은 더 이상 '**객체에 닿을 수 없을 때**'를 말합니다. 닿는다는 roots(전역 변수)를 기준으로 참조, 또는 참조의 참조의… 참조가 되는 객체들입니다. 이 알고리즘을 **mark and sweep**이라고 부르는데 가비지 컬렉터는 ‘root에서 닿을 수 있는’ **객체들의 reachable을 true로 표시하고, false인 객체들은 메모리에서 해제**시킵니다.

---

[참고]

https://github.com/Esoolgnah/Frontend-Interview-Questions/blob/main/Notes/important-5/closure.md
