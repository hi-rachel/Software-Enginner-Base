## 호이스팅(Hoisting)

**호이스팅이란 JS에서 변수나 함수 선언문이 해당 스코프의 최상단으로 끌어올려지는 현상을 의미합니다.**
이로 인해 코드에서 변수를 선언하기 전에 참조할 수 있는 것처럼 보이는 현상이 발생합니다.
호이스팅은 변수와 함수의 선언만 끌어올려지며 초기화(대입문)는 끌어올려지지 않습니다.

### 호이스팅이 일어나는 이유

호이스팅은 자바스크립트 엔진이 코드를 실행하기 전에 실행 컨텍스트를 만들면서 변수와 함수 선언을 메모리에 먼저 올려두기 때문에 발생합니다.
그래서 선언문이 코드 위로 끌어올려진 것처럼 보이지만 사실은 메모리에 미리 등록되는 과정 때문에 생기는 현상입니다.

1. 자바스크립트의 실행 과정 때문

   • JS 엔진은 코드를 실행하기 전에 두 단계를 거칩니다:

   1. 생성 단계 (Creation Phase): 변수/함수 선언을 메모리에 먼저 등록.

   2. 실행 단계 (Execution Phase): 실제 코드 한 줄씩 실행.

      • 이때 선언부가 실행 전에 메모리에 등록되기 때문에, 선언이 “끌어올려진 것처럼” 보이는 현상이 발생합니다.

2. 변수 환경(Variable Environment)과 렉시컬 환경(Lexical Environment)

   • 실행 컨텍스트가 생성될 때, 변수와 함수 선언이 먼저 환경에 기록됩니다.

   • → 그래서 선언 전에 접근해도 undefined가 나오거나 (var), 함수는 바로 호출이 가능하게 됩니다.

3. [함수 선언](함수.md)과 변수 선언 처리 방식의 차이

   • var: 선언은 호이스팅되지만, 초기화는 실행 단계에서 이루어져서 undefined.

   • let/const: 선언은 호이스팅되지만 TDZ(Temporal Dead Zone) 때문에 초기화 전 접근 시 에러.

   • 함수 선언문: 전체가 호이스팅 → 선언 전에 호출 가능.

   • 함수 표현식: 변수 호이스팅 규칙 따름 (초기화 전에는 undefined 또는 TDZ 에러).

## var, let, const 키워드 관점에서 호이스팅 설명해주세요.

**var은 함수 스코프로 선언과 초기화가 동시에 이루어집니다.**

**let, const는 블록 스코프로 선언 단계에서만 호이스팅이 됩니다.**

따라서 var로 선언하기 전에 해당 변수를 console.log 해보면 할당된 undefined가 출력되고,

let, const로 선언하기 전 해당 변수를 consoel.log 해보면 Reference Error가 출력됩니다.

## ReferenceError가 발생하는 이유, TDZ(일시적 사각지대) 설명

let, const로 선언한 변수는 선언과 동시에 초기화되지 않고 선언만 호이스팅이 됩니다. 따라서 **초기화가 되기 전에는 참조가 불가능**한데 이 상태를 표현하기 위해 **TDZ(Temporal Dead Zone)** 개념이 사용됩니다. **선언 전에 변수를 사용하는 것을 허용하지 않는 개념상의 공간**입니다.

TDZ에 있는 식별자에 접근하는 것은 ReferenceError를 발생시킵니다.

---

💡 블록 스코프란?

ES6에서 도입된 개념으로, 중괄호 {}로 둘러싸인 코드 블록 내에서 선언된 변수는 해당 블록 스코프에서만 유효하다는 의미입니다.

💡 함수 스코프란?

함수 스코프란 함수 내에서 선언된 변수들이 해당 함수 내에서만 접근 가능하다는 것을 의미합니다. 블록({}) 내부에서 선언된 변수도 함수 스코프 내에 포함됩니다.

💡 [실행 컨텍스트](실행-컨텍스트.md)

자바스크립트 코드가 실행되는 환경(환경 정보 묶음)을 의미합니다.
엔진이 코드를 실행할 때 필요한 변수, 함수 선언, this, 스코프 체인 등을 모아 관리하는 일종의 '실행 단위'입니다.

---

[참고]

https://github.com/Esoolgnah/Frontend-Interview-Questions/blob/main/Notes/important-5/hoisting.md
